<template>
	<div class="page">
	  <!-- scroll 组件：绑定 scrolltop 与 scrollbottom 事件 -->
	  <scroll id="scrollId"
		style="position: absolute; width: 192px; height: 490px;"
		scroll-y="{{true}}"
		@scroll="onScroll"
		@scrolltop="onScrollTop"
		@scrollbottom="onScrollBottom"
		@click="onTxtClick"
		onlongpress="onTxtLongPress"
		>

		<!-- 内容容器采用 flex 布局 -->
		<div id="contentContainer" style="position: absolute; padding:100px 0px; width:192px; flex-direction: column;">
		  <!-- 上方加载提示 -->
		  <text if="{{loadingPrev}}"
			style="width: 192px; text-align: center; color: #0D91FF; font-size: 24px;padding: 10px 0;">
			加载中...
		  </text>

		  <!-- 循环显示双页文本 -->
		  <text for="{{segments}}"
			id="{{'segment-' + $idx}}"
			style="width: 192px; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; ">
			{{$item.text}}
		  </text>

		  <!-- 下方加载提示 -->
		  <text if="{{loadingNext}}"
			style="width: 192px; text-align: center; color: #0D91FF; font-size: 24px;padding: 10px 0;">
			加载中...
		  </text>
		</div>
	  </scroll>

	  <!-- 底部其他交互按钮 -->
	  <img show="{{showSetting}}" src="/common/images/mask_up.png" style="position: absolute; top: 0; left: 0;"/>
	  <img show="{{showSetting}}" src="/common/images/back.png" @click="back" style="position: absolute; left: 45px;top: 6px;width: 102px;height: 72px;"/>
	  <img show="{{showSetting}}" src="/common/images/mask_down.png" style="position: absolute; left: 0px; top: 372px;"/>
	  <img show="{{showSetting}}" src="/common/images/more.png" style="position: absolute; left: 45px;top: 412px;width: 102px;height: 72px;" @click="gotoSetting"/>

	  <!-- <text style="position: absolute; left: 0px; top: 240px; width: 212px; font-weight:bold; font-size:20px; color:blue;">
		{{debugOutput}}
	  </text> -->
	</div>
  </template>

  <script>
	import prompt from '@system.prompt'
	import file from '@system.file'
	import router from '@system.router'
  import storage from '../../common/storage.js'
	import brightness from '@system.brightness'

	// 每页文本字节数（实际读取字节数为 txtSizePage*2）
	var txtSizePage = 500;
	var allSize = 0;
	var SAVED_KEY = "EBOOK_SAVED";

    let autoInterval = null; // 自动翻页定时器

	export default {
	  private: {
		fPath: '',
		persent: 0,          // 阅读百分比（0～100）
		fontSize: 30,
		lineHeight: 34,
		pageHeigh: 520, // 与页面 scroll 高度保持一致，避免滚动步长不对齐导致跳页
		showSetting: true,
		loadingNext: false,   // 防止重复加载下一页
		loadingPrev: false,   // 防止重复加载上一页
		// 双页模式：segments 数组最多存放两个页面内容
		segments: [],
		debugOutput: "初始化中...",
		currentFileOffset: 0, // 当前顶部页面在文件中的起始偏移（字节）
		opacity: 100,
		swipe: 'column',
		auto: false,
		savedScrollOffset: 0,
		currentScrollTop: 0,
		isPaging: false, // 翻页锁，防止在翻页动画期间重复触发加载导致跳多页
		pagingTimer: null, // onScroll 去抖定时器
		// 新增：滚动精确计算去抖定时器
		scrollCalcTimer: null,
		// 新增：双击判定相关
		lastClickTime: 0,
		singleClickTimer: null,
		// 手动常亮标记（双击切换）
		manualKeepScreenOn: false
	  },
	  protected: {
		cPath: '',
		name: ''  // 当前书籍名称或文件名，用作全局保存进度的键
	  },
	  onInit(){
		var that = this;
		// 初次启动提示（保持原有逻辑）
		storage.get({
		  key: 'EBOOK_TIPS',
		  success: function(data) {
			if(data != "1"){
			  storage.set({
				key: 'EBOOK_TIPS',
				value: '1',
				success: function(){
				  that.routerTo('info');
				}
			  });
			}
		  },
		  fail: function(){
			storage.set({
			  key: 'EBOOK_TIPS',
			  value: '1',
			  success: function(){
				that.routerTo('info');
			  }
			});
		  }
		});
	  },
	  onShow(){
		var that = this;
		// 读取全局保存的进度，恢复 currentFileOffset 和 persent
		this.initReadFile();
		// 读取字号设置
		storage.get({
		  key: 'EBOOK_FONT',
		  success: function(data){
			if(data){
			  that.fontSize = parseInt(data);
			  that.lineHeight = parseInt((-0.01)*(that.fontSize**2) + 1.62*that.fontSize - 3.23);
			} else {
			  storage.set({
				key: 'EBOOK_FONT',
				value: that.fontSize.toString()
			  });
			}
			that.pageHeigh = Math.floor(that.pageHeigh/that.lineHeight) * that.lineHeight;
		  },
		  fail: function(){}
		});
		storage.get({
		  key: 'EBOOK_OPACITY',
		  success: function(data) {
			if (data) {
				that.opacity = parseInt(data)
				console.log("当前字号："+that.fontSize);
				console.log("当前透明度："+that.opacity);
			} else {
				storage.set({
					key: 'EBOOK_OPACITY',
					value: '100'
				});
				that.opacity = 100
			}
		  },
		})
		storage.get({
		  key: 'EBOOK_SWIPE',
		  success: function(data) {
			if (data) {
				that.swipe = data
			} else {
				storage.set({
					key: 'EBOOK_SWIPE',
					value: 'column'
				});
				that.swipe = 'column'
			}
		  },
		})
		storage.get({
		  key: 'EBOOK_AUTO',
 			success: (data) => {
				if(!data)return;
				const { speed, enable } = JSON.parse(data);
				if(enable)this.auto = speed;
		  }
		})
		// 注意：不在 onShow 立刻滚动（内容可能尚未渲染），改为在加载初始两页后恢复位置
	  },
	  onScroll(e){
		const that = this;
		that.currentScrollTop = e.scrollY;
		// 非分页动画期间也实时记录当前位置用于恢复（解决只能第一页精确的问题）
		if(!this.isPaging){
			this.savedScrollOffset = that.currentScrollTop;
		}
		// 新增：无论是否分页锁，均尝试去抖计算精确百分比
		this.updatePrecisePercentDebounced();
		// 如果处于翻页锁定状态，使用去抖判断滚动是否结束再释放锁
		if(this.isPaging){
			if(this.pagingTimer) clearTimeout(this.pagingTimer);
			this.pagingTimer = setTimeout(function(){
				try{
					// 计算最近的页面对齐位置并对齐
					let scrollY = that.currentScrollTop || 0;
					let page = Math.round(scrollY / that.pageHeigh);
					let target = page * that.pageHeigh;
					that.$element("scrollId").scrollTo({ top: target, left: 0, behavior: 'instant' });
					// 更新 savedScrollOffset 以便保存正确位置
					that.savedScrollOffset = target;
					that.isPaging = false;
				}catch(e){}
			}, 160); // 160ms 去抖，视设备可调整
		}
	  },
	  // 新增：去抖触发精确百分比计算
	  updatePrecisePercentDebounced(){
		if(this.scrollCalcTimer) clearTimeout(this.scrollCalcTimer);
		this.scrollCalcTimer = setTimeout(()=>{ this.computePrecisePercent(); }, 120);
	  },
	  // 新增：计算精确阅读百分比（按当前滚动位置在两个段落中的相对位置估算字节偏移）
	  computePrecisePercent(){
		if(!this.segments || this.segments.length === 0 || allSize === 0) return;
		const scrollY = this.currentScrollTop;
		const first = this.segments[0];
		const second = this.segments.length > 1 ? this.segments[1] : null;
		const baseOffset = first.offset;
		const that = this;
		// 获取第一段高度
		this.$element('segment-0').getBoundingClientRect({
		  success: function(r0){
			let h0 = r0.height || 1; // 防止除零
			if(!second){
			  // 只有一段
			  let ratio0 = Math.min(Math.max(scrollY / h0, 0), 1);
			  let eff = baseOffset + Math.floor(first.length * ratio0);
			  that.persent = parseInt(eff * 100 / allSize);
			  that.savedScrollOffset = that.currentScrollTop; // 同步保存
			  return;
			}
			// 有第二段，再取第二段高度
			that.$element('segment-1').getBoundingClientRect({
			  success: function(r1){
				let h1 = r1.height || 1;
				let effOffset;
				if(scrollY <= h0){
				  let ratio0 = Math.min(Math.max(scrollY / h0, 0), 1);
				  effOffset = baseOffset + Math.floor(first.length * ratio0);
				} else {
				  let y1 = scrollY - h0;
				  let ratio1 = Math.min(Math.max(y1 / h1, 0), 1);
				  effOffset = baseOffset + first.length + Math.floor(second.length * ratio1);
				}
				that.persent = parseInt(effOffset * 100 / allSize);
				that.savedScrollOffset = that.currentScrollTop; // 同步保存
			  },
			  fail: function(){
				// 第二段高度获取失败，退化为只按第一段计算
				let ratio0 = Math.min(Math.max(scrollY / h0, 0), 1);
				let eff = baseOffset + Math.floor(first.length * ratio0);
				that.persent = parseInt(eff * 100 / allSize);
				that.savedScrollOffset = that.currentScrollTop; // 同步保存
			  }
			});
		  },
		  fail: function(){ /* 获取失败忽略 */ }
		});
	  },
	  //【读取进度】从全局存储中恢复当前书籍的记录（格式 {"book1":{"p":..., "s":..., "o":0}, ...}）
	  initReadFile(){
		var that = this;
		storage.get({
		  key: SAVED_KEY,
		  success: function(data){
			var globalData = {};
			if(data){ globalData = JSON.parse(data); }
			if(globalData[that.name] && (globalData[that.name].s || globalData[that.name].s === 0)){
			  that.currentFileOffset = globalData[that.name].s;
			  that.persent = globalData[that.name].p || 0;
			  that.savedScrollOffset = globalData[that.name].o;
			  
			} else {
			  that.currentFileOffset = 0;
			}
			that.readFile();
		  },
		  fail: function(){
			that.currentFileOffset = 0;
			that.readFile();
		  }
		});
	  },
	  readFile(){
		var that = this;
		var path = this.cPath;
		file.access({
		  uri: path,
		  success: function(){
			file.get({
			  uri: path,
			  success: function(data){
				allSize = data.length;
				// 从 currentFileOffset 开始加载初始双页内容
				that.loadInitialSegments();
			  },
			  fail: function(){ that.readError(); }
			});
		  },
		  fail: function(){ that.readError(); that.back(); }
		});
	  },
	  // 加载初始双页：先加载第一页，再加载第二页（如果存在）
	// 将恢复滚动的逻辑放在初始两页读取完成后，避免恢复时页面高度变化导致位置偏移
	  loadInitialSegments(){
		var that = this;
		this.readFileText(this.currentFileOffset, function(str, bytesRead){
		  that.segments = [{ text: str, offset: that.currentFileOffset, length: bytesRead }];
		  // 读取第二页（如果有），读取完成后再恢复滚动位置
		  let nextOffset = that.currentFileOffset + bytesRead;
		  if(nextOffset < allSize){
			that.readFileText(nextOffset, function(str2, bytesRead2){
			  if(str2){
				that.segments.push({ text: str2, offset: nextOffset, length: bytesRead2 });
			  }
			  // 等待视图渲染后恢复滚动位置（短延时更稳健）
			  setTimeout(function(){
				try{
				  that.$element("scrollId").scrollTo({
					top: that.savedScrollOffset || 0,
					left: 0,
					behavior: 'instant'
				  });
				  console.log("恢复进度（初始化后）："+that.savedScrollOffset);
				  that.computePrecisePercent(); // 初始恢复后计算一次精确进度
				}catch(e){}
			  }, 80);
			});
		  } else {
			// 只有一页时也恢复滚动
			setTimeout(function(){
			  try{
				that.$element("scrollId").scrollTo({
				  top: that.savedScrollOffset || 0,
				  left: 0,
				  behavior: 'instant'
				});
				console.log("恢复进度（单页）："+that.savedScrollOffset);
				that.computePrecisePercent();
			  }catch(e){}
			}, 80);
		  }
		});
	  },
	  // 不做翻页调整，仅追加一页（用于初始加载）
	  loadNextSegmentNoScroll(){
		var that = this;
		let lastSeg = that.segments[that.segments.length - 1];
		let newOffset = lastSeg.offset + lastSeg.length;
		if(newOffset >= allSize) return;
		that.readFileText(newOffset, function(str, bytesRead){
		  if(str){
			that.segments.push({ text: str, offset: newOffset, length: bytesRead });
			// 更新保存信息（顶部段代表当前进度）
			that.currentFileOffset = that.segments[0].offset;
			that.persent = parseInt(that.currentFileOffset * 100 / allSize);
			// that.saveData();
		  }
		});
	  },
	  //【读取文件文本】回调返回文本内容和实际读取的字节数
	  readFileText(readOffset, cb){
		if(readOffset >= allSize){
		  cb('', 0);
		  return;
		}
		var length = txtSizePage * 2;
		if(readOffset < 0){
		  length = length + readOffset;
		  readOffset = 0;
		}
		if((readOffset + length) >= allSize){
		  length = allSize - readOffset;
		}
		var that = this;
		file.readArrayBuffer({
		  uri: that.cPath,
		  position: readOffset,
		  length: length,
		  success: function(data){
			var str = '';
			for(var i = 0; i < data.buffer.length; i += 2){
			  str += String.fromCharCode(data.buffer[i+1]*256 + data.buffer[i]);
			}
			cb(str, length);
		  },
		  fail: function(){
			that.readError();
			cb('', 0);
		  }
		});
	  },
	  //【向下翻页】（scrollbottom 触发）
	  // 追加下一页内容；若双页数量超过 2，则移除顶部页面，并调用 scrollBy 向上偏移被移除页面高度
	  onScrollBottom(event){
		// 如果正在执行翻页动画或正在处理加载，则忽略重复触发
		if(this.isPaging) return;
		if(!this.loadingNext){
		  this.loadingNext = true;
		  this.loadNextSegment();
		}
	  },
	  loadNextSegment(){
        var that = this;
        let lastSeg = that.segments[that.segments.length - 1];
        let newOffset = lastSeg.offset + lastSeg.length;
        if(newOffset >= allSize){
          this.loadingNext = false;
          return;
        }
        this.readFileText(newOffset, function (str, bytesRead) {
          that.loadingNext = false;
          if(str){
            that.segments.push({ text: str, offset: newOffset, length: bytesRead });
            // 超过双页时：先测量即将被移除的顶部段落高度，再移除并滚动补偿，避免跳动
            if (that.segments.length > 2) {
              that.$element("segment-0").getBoundingClientRect({
                success: function(rect){
                  let removedHeight = rect.height;
                  // 数据移除
                  that.segments.shift();
                  // 位置补偿
                  that.$element("scrollId").scrollBy({
                    top: -removedHeight,
                    left: 0,
                    behavior: 'instant'
                  });
                },
                fail: function(){
                  // 测量失败仍移除以防堆积
                  that.segments.shift();
                }
              });
            }
            that.currentFileOffset = that.segments[0].offset;
            that.persent = parseInt(that.currentFileOffset * 100 / allSize);
            that.saveData();
          }
        });
	  },
	  //【向上翻页】（scrolltop 触发）
	  // 预先加载上一页内容，并插入到数组头部；如果超过两页，则移除底部页面，并调用 scrollBy 向下偏移新插入页面高度
	  onScrollTop(event){
		// 同样加锁避免重复触发
		if(this.isPaging) return;
		if(!this.loadingPrev && this.currentFileOffset > 0){
		  this.loadingPrev = true;
		  this.loadPrevSegment();
		}
	  },
	  loadPrevSegment(){
		var that = this;
		let firstSeg = that.segments[0];
		let newOffset = firstSeg.offset - txtSizePage * 2;
		if(newOffset < 0) newOffset = 0;
		if(firstSeg.offset <= 0){
		  this.loadingPrev = false;
		  return;
		}
  		  this.readFileText(newOffset, function (str, bytesRead) {
		  that.loadingPrev = false;
		  if(str){
			that.segments.unshift({ text: str, offset: newOffset, length: bytesRead });
			that.$element("segment-0").getBoundingClientRect({
			  success: function(rect){
				let insertedHeight = rect.height;
				// 向下滚动 insertedHeight，保持当前内容位置不变
				that.$element("scrollId").scrollBy({
				  top: insertedHeight,
				  left: 0,
				  behavior: 'instant'
				});
			  },
			  fail: function(){}
			});
			// 若超过两页，移除底部页面
			if(that.segments.length > 2){
			  that.segments.pop();
			}
			that.currentFileOffset = that.segments[0].offset;
			that.persent = parseInt(that.currentFileOffset * 100 / allSize);
			that.saveData();
		  }
		});
	  },
	  readError(){
		prompt.showToast({
		  message: '文件读取失败',
		  duration: 2000
		});
	  },
	  gotoSetting(){
		// 立即保存并跳转（去掉无必要延迟与前导/，避免路径解析失败）
		this.saveData();
		try {
			router.push({
				uri: 'pages/detailsetting/detailsetting', // 若实际文件为 pages/detailsetting/index 则改成对应路径
				params: { cPath: this.cPath, name: this.name, size: allSize }
			});
		} catch(e){
			prompt.showToast({ message: '进入设置失败: '+ (e && e.message ? e.message : e), duration: 2000 });
		}
	  },
	  //【保存进度】只更新当前书籍对应的记录，格式 {"book1":{"p":..., "s":..., "o":0}, ...}
	  saveData(){
		var that = this;
		// 保存前尝试更新一次精确百分比（避免尚未触发去抖时离开）
		this.computePrecisePercent();
		storage.get({
		  key: SAVED_KEY,
		  success: function(data){
			var globalData = {};
			if(data){ globalData = JSON.parse(data); }
			globalData[that.name] = {
			  s: that.currentFileOffset,
			  p: that.persent,
			  o: that.currentScrollTop
			};
			storage.set({
			  key: SAVED_KEY,
			  value: JSON.stringify(globalData)
			});
		  },
		  fail: function(){
			var globalData = {};
			globalData[that.name] = {
			  s: that.currentFileOffset,
			  p: that.persent,
			  o: that.currentScrollTop
			};
			storage.set({
			  key: SAVED_KEY,
			  value: JSON.stringify(globalData)
			});
		  }
		});
		console.log('保存数据: '+ this.name + ': ' + this.currentFileOffset + ' ' + this.persent + ' ' + this.currentScrollTop);
	  },
	  onHide(){
		// 先保存进度
		try{ this.saveData(); }catch(e){}
		// 处理自动翻页定时器
		if(autoInterval){
			clearInterval(autoInterval);
			autoInterval = null;
			prompt.showToast({
					message: '已关闭自动翻页',
					duration: 2000
				});
		}
		// 无论来源（自动/手动）离开页面都关闭常亮
		if(this.manualKeepScreenOn || autoInterval === null){
			brightness.setKeepScreenOn({ keepScreenOn: false });
		}
	  },
	  onDestroy(){
		if (this.auto) {
			clearInterval(autoInterval);
			autoInterval = null;
		}
		// 清理 onScroll 去抖定时器
		if(this.pagingTimer){
			clearTimeout(this.pagingTimer);
			this.pagingTimer = null;
		}
		// 清理单击定时器
		if(this.singleClickTimer){
			clearTimeout(this.singleClickTimer);
			this.singleClickTimer = null;
		}
		// 退出时关闭常亮
		if(this.manualKeepScreenOn || autoInterval === null){
			brightness.setKeepScreenOn({ keepScreenOn: false });
		}
	  },
	  onBackPress(){
		this.back()
		return true;
	  },
	  back(){
		// 去掉延迟直接返回，避免某些情况下无法退出
		this.saveData();
		try { router.back(); }
		catch(e){ prompt.showToast({ message: '返回失败', duration:2000 }); }
	  },
	  routerTo(url){
		// 统一去掉前导/，与 manifest 中定义保持一致
		try { router.push({ uri: 'pages/' + url + '/' + url }); }
		catch(e){ prompt.showToast({ message: '跳转失败', duration:2000 }); }
	  },
  	onTxtClick(event) {
		// 新增：双击检测。双击 300ms 内第二次点击触发屏幕常亮切换，单击延后执行原逻辑
		const now = Date.now();
		if (this.lastClickTime && (now - this.lastClickTime) < 300) {
			// 认定为双击
			if (this.singleClickTimer) { clearTimeout(this.singleClickTimer); this.singleClickTimer = null; }
			this.lastClickTime = 0;
			this.toggleKeepScreenOn();
			return;
		}
		this.lastClickTime = now;
		if (this.singleClickTimer) { clearTimeout(this.singleClickTimer); }
		this.singleClickTimer = setTimeout(() => {
			// ...existing single click behavior...
			if (this.swipe === 'column') {
				this.showSetting = !this.showSetting;
			} else {
				if (this.showSetting) {
					this.showSetting = false;
				} else {
					if (event.offsetY <= 178) {
						this.lastPage();
					} else if (event.offsetY <= 342) {
						this.showSetting = !this.showSetting;
					} else {
						this.nextPage();
					}
				}
			}
		}, 300);
	},
	onTxtLongPress(event) {
  		if (this.auto) {
			if(autoInterval){
				clearInterval(autoInterval);
				autoInterval = null;
				prompt.showToast({
					message: '已关闭自动翻页',
					duration: 2000
				});
				// 若仍有手动常亮则保持，否则关闭
				brightness.setKeepScreenOn({ keepScreenOn: this.manualKeepScreenOn });
				return;
			}

			autoInterval = setInterval(() => {
				this.nextPage();
			}, this.auto*1000);
			prompt.showToast({
				message: '已开启自动翻页',
				duration: 2000
			});
			brightness.setKeepScreenOn({ keepScreenOn: true });
		}
	},
	// 新增：双击切换屏幕常亮
	toggleKeepScreenOn(){
		this.manualKeepScreenOn = !this.manualKeepScreenOn;
		// 若自动翻页开启则始终保持常亮；否则根据手动标记
		const keep = this.manualKeepScreenOn || !!autoInterval;
		brightness.setKeepScreenOn({ keepScreenOn: keep });
		prompt.showToast({
			message: this.manualKeepScreenOn ? '已开启常亮(双击)' : '已关闭常亮(双击)',
			duration: 2000
		});
	},
	onTxtSwipe(event){
		if(event.direction === 'right'){
		  this.back();
		}
  	},
	lastPage() {
		// 启动分页锁，防止在动画期间触发多次加载
		this.isPaging = true;
		this.$element("scrollId").scrollBy({
			top: - this.pageHeigh,
			left: 0,
			behavior: 'smooth'
		  });
		// 预计动画时长后释放锁（延长为 600ms 以适配较慢设备）
		setTimeout(() => { this.isPaging = false; }, 300);
	},
	nextPage() {
		// 启动分页锁，防止在动画期间触发多次加载
		this.isPaging = true;
		this.$element("scrollId").scrollBy({
			top: this.pageHeigh,
			left: 0,
			behavior: 'smooth'
		  });
		// 预计动画时长后释放锁（延长为 600ms 以适配较慢设备）
		setTimeout(() => { this.isPaging = false; }, 300);
	  }
	}
  </script>

<style>
.page {
	width: 192px;
	height: 490px;
	background-color: #000000;
}
</style>

